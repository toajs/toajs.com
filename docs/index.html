<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Toa | A pithy and powerful web framework</title>
    <meta charset="utf-8">
    <meta name="keywords" content="toa, web, app, http, application, framework, thunk, thunks">
    <meta name="description" content="A pithy and powerful web framework.">
    <meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <link rel="stylesheet" href="static/css/lib.fff14453.css"/>
    <link rel="stylesheet" href="static/css/app.47bfeea6.css"/>
  </head>
  <body>
    <div class="page-index">
  <section class="heading" id="heading">
  <div class="logo">TOA</div>
  <p class="desc">A pithy and powerful web framework</p>
  <a href="https://github.com/toajs/toa" target="_blank" class="btn btn-lg btn-info main-handler">
    Get TOA
  </a>
</section>

  <section class="navbar navbar-default site-header">
  <div class="container">
    <div class="navbar-header">
      <div class="clearfix">
        <ul class="nav navbar-nav">
          <li class="nav-handler">
            <a href="#introduction" title="">Introduction</a>
          </li>
          <li class="nav-handler">
            <a href="#get-started" title="">Get started</a>
          </li>
          <li class="nav-handler dropdown">
            <a class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="#doc-application">Application</a></li>
              <li><a href="#doc-context">Context</a></li>
              <li><a href="#doc-request">Resuest</a></li>
              <li><a href="#doc-response">Response</a></li>
            </ul>
          </li>
          <li class="nav-handler">
            <a href="#resources" title="">Resources</a>
          </li>
          <li class="nav-handler">
            <a href="#thanks" title="">Thanks</a>
          </li>
        </ul>
        <ul class="nav navbar-nav more-handlers pull-right">
          <li class="nav-handler with-icon dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown">
            <i class="mdi-navigation-more-vert"></i>
          </a>
          <ul class="dropdown-menu">
            <li><a class="cant-click">Follow author</a></li>
            <li class="divider"></li>
            <li><a href="https://github.com/zensh" target="_blank">On Github</a></li>
            <li><a href="http://weibo.com/zensh" target="_blank">On Weibo</a></li>
          </ul>
        </li>
      </div>
    </div>
    <div class="github-star-handler" title="Star on Github">
      <a href="https://github.com/toajs/toa" target="_blank" class="btn btn-fab btn-info">
        <i class="mdi-action-grade"></i>
      </a>
    </div>
  </div>
</section>

  <section class="introduction" id="introduction">
  <div class="container">
    <div class="card">
      <div class="card-main">
        <div class="row features">
          <div class="col-sm-4">
            <div class="sub-card">
              <div class="sub-card-header">
                <div class="intro-icon icon-quick-start"></div>
              </div>
              <h3>快速上手</h3>
              <p><strong>Toa</strong> 与 <strong>Koa</strong> 学习成本和编程体验是一致的，两者之间几乎是无缝切换</p>
            </div>
          </div>
          <div class="col-sm-4">
            <div class="sub-card">
              <div class="sub-card-header">
                <div class="intro-icon icon-thunks"></div>
              </div>
                <h3>基于 Thunks</h3>
                <p>由 Thunks 组合业务逻辑，用同步逻辑编写非阻塞的异步程序和异常处理</p>
            </div>
          </div>
          <div class="col-sm-4">
            <div class="sub-card">
              <div class="sub-card-header">
                <div class="intro-icon icon-modularize"></div>
              </div>
                <h3>模块化</h3>
                <p>弱化中间件，强化模块化组件，使得编写大型应用的结构逻辑更清晰，也更安全</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

  <svg id="get-started-gap" xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100" viewBox="0 0 100 100" preserveAspectRatio="none">
  <path d="M0 100 C 20 0 50 0 100 100 Z"></path>
</svg>
<section class="get-started" id="get-started">
  <div class="container">
    <div class="card">
      <div class="card-header with-border">
        <h2>Get started</h2>
      </div>
      <div class="card-main">
          <h3>"Hello world" snippet</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Toa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'toa'</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-number">new</span> Toa()
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params"> ()</span> </span>{
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello World!\n-- toa'</span>
})
app.listen(<span class="hljs-number">3100</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params"> ()</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n'</span>, <span class="hljs-string">'listening on port'</span>, <span class="hljs-number">3100</span>, <span class="hljs-string">'in dev env'</span>)
})
</code></pre>
        <h3>Install Toa & startup Toa</h3>
        <div class="app-frame terminal-window">
          <header>
            <div class="button red"></div><div class="button yellow"></div><div class="button green"></div>
            <span class="title">Terminal</span>
          </header>
          <section class="frame-main terminal-main">
            <div class="history"></div>
            $&nbsp;<span class="prompt"></span>
            <span class="typed-cursor"></span>
          </section>
        </div>
        <div class="app-frame-data terminal-data run-output">
          <br>&nbsp;
          <span>&nbsp;&nbsp;listening on port <span class="orange">3100</span> in <span class="green">dev env</span></span>
          <br>&nbsp;
        </div>
      </div>
    </div>
  </div>
</section>

  <section class="documentation" id="documentation">
  <div class="card">
    <div class="card-header with-border">
      <h2>Documentation</h2>
    </div>
    <div class="card-main">
      <div class="readable">
        <h1>Toa</h1>
<p>简洁而强大的 web 框架。</p>
<h2>Thanks to <a href="https://github.com/koajs/koa">Koa</a> and it’s authors</h2>
<h2 id="doc-summary">Summary</h2>
<ul>
<li><a href="#toa">Toa 简介</a></li>
<li><a href="#application">Application 应用</a></li>
<li><a href="#context">Context 对象</a></li>
<li><a href="#request">Request 对象</a></li>
<li><a href="#response">Response 对象</a></li>
</ul>
<h2>Toa 简介</h2>
<p><strong>Toa</strong> 修改自 <strong>Koa</strong>，基本架构原理与 <strong>Koa</strong> 相似，<code>context</code>、<code>request</code>、<code>response</code> 三大基础对象几乎一样。</p>
<p><strong>Toa</strong> 是基于 <a href="https://github.com/thunks/thunks">thunks</a> 组合业务逻辑，来实现异步流程控制和异常处理。<code>thunks</code> 是一个比 <code>co</code> 更强大的异步流程控制工具，支持所有形式的异步控制，包括 callback，promise，generator，async/await 等。</p>
<p><strong>Toa</strong> 支持 <code>Node.js v0.12</code> 以上，但在高版本中将有更好的体验和性能，如 <code>&gt;=v4</code> 的版本支持 generator 函数，<code>&gt;=v7</code> 的版本支持 async/await 函数，这些特性支持<strong>用同步逻辑编写非阻塞的异步程序</strong>。</p>
<p><strong>Toa</strong> 与 <strong>Koa</strong> 学习成本和编程体验是一致的，两者之间几乎是无缝切换。但 <strong>Toa</strong> 去掉了 <strong>Koa</strong> 的 <code>级联（Cascading）</code> 逻辑，强化中间件，尽量削弱第三方组件访问应用的能力，使得编写大型应用的结构逻辑更简洁明了，也更安全。</p>
<h3>安装 Toa</h3>
<pre><code class="language-sh">npm install toa
</code></pre>
<h2 id="doc-application">Application</h2>
<p>一个 Toa Application（以下简称 <strong>app</strong>）由一系列 <strong>中间件</strong> 组成。<strong>中间件</strong> 是指通过 <code>app.use</code> 加载的同步函数、thunk 函数、generator 函数或 async/await 函数。</p>
<p>对于 web server 的一次访问请求，app 会按照顺序先运行中间件，然后再运行业务逻辑中 <code>context.after(hook)</code> 动态添加的 hooks，最后运行内置的 <code>respond</code> 函数，将请求结果自动响应的客户端。由于 Toa 没有 <code>级联（Cascading）</code>，这些中间件或模块的运行不会有任何交叉，它们总是先运行完一个，再运行下一个。</p>
<p>Toa 只有一个极简的内核，提供快捷的 HTTP 操作和异步流程控制能力。具体的业务功能逻辑则由中间件和模块组合实现。用户则可根据自己的业务需求，以最轻量级的方式组合自己的应用。</p>
<p>让我们来看看 Toa 极其简单的 Hello World 应用程序：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Toa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'toa'</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Toa()

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello World!\n-- toa'</span>
})

app.listen(<span class="hljs-number">3000</span>)
</code></pre>
<h3>Class: Toa()</h3>
<h3>Class: Toa(server)</h3>
<h3>Class: Toa(options)</h3>
<h3>Class: Toa(onerror)</h3>
<h3>Class: Toa(server, options)</h3>
<ul>
<li><code>server</code>: {Object}, http server 或 https server 实例。</li>
<li><code>options</code>: {Object} 类似 <code>thunks</code> 的 options，对于 server 的每一个 <strong>client request</strong>，toa app 均会用 <code>thunks</code> 生成一个的 <code>thunk</code>，挂载到 <code>context.thunk</code>，该 <code>thunk</code> 的作用域对该 <strong>client request</strong> 的整个生命周期生效。
<ul>
<li><code>options.onerror</code>: {Function} 其 <code>this</code> 为 <strong>client request</strong> 的 <code>context</code> 对象。当 <strong>client request</strong> 处理流程出现异常时，会抛出到 <code>onerror</code>，原有处理流程会终止，<code>onerror</code> 运行完毕后再进入 toa 内置的异常处理流程，最后 <code>respond</code> 客户端。如果 <code>onerror</code> 返回 <code>true</code>，则会忽略该异常，异常不会进入内置异常处理流程，然后直接 <code>respond</code> 客户端。</li>
</ul></li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// with full arguments</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Toa(server, {
  <span class="hljs-attr">onerror</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{}
})
</code></pre>
<h4>app.keys = ['key1’, ‘key2’]</h4>
<p>设置 cookie 签名密钥，参考 <a href="https://github.com/expressjs/keygrip">Keygrip</a>。<br>
注意，签名密钥只在配置项 <code>signed</code> 参数为真时才会生效：</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.cookies.set(<span class="hljs-string">'name'</span>, <span class="hljs-string">'test'</span>, {<span class="hljs-attr">signed</span>: <span class="hljs-literal">true</span>})
</code></pre>
<h4>app.config = config</h4>
<p>config 会被 <code>context.config</code> 继承，但 <code>context.config</code> 不会修改 <code>app.config</code>。</p>
<pre><code class="language-js">app.config = config
</code></pre>
<p>app.config 默认值：</p>
<pre><code class="language-js">{
  <span class="hljs-attr">proxy</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 决定了哪些 `proxy header` 参数会被加到信任列表中</span>
  env: process.env.NODE_ENV || <span class="hljs-string">'development'</span>, <span class="hljs-comment">// node 执行环境</span>
  subdomainOffset: <span class="hljs-number">2</span>,
  <span class="hljs-attr">poweredBy</span>: <span class="hljs-string">'Toa'</span>
}
</code></pre>
<h4>app.use(function () {})</h4>
<h4>app.use(function (callback) {})</h4>
<h4>app.use(function * () {})</h4>
<h4>app.use(async function () {})</h4>
<p>加载中间件，返回 <code>app</code>，<code>fn</code> 必须是 <code>thunk</code> 函数或 <code>generator</code> 函数，函数中的 <code>this</code> 值为 <code>context</code>。</p>
<pre><code class="language-js">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-comment">// task</span>
  <span class="hljs-comment">// this === context</span>
  callback(err, result)
})
</code></pre>
<pre><code class="language-js">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// task</span>
  <span class="hljs-comment">// this === context</span>
  <span class="hljs-keyword">yield</span> result
})
</code></pre>
<h4>app.onerror = function (error) {}</h4>
<p>设置 <code>onerror</code> 函数，当 app 捕捉到程序运行期间的错误时，会先使用 <code>options.onerror</code>（若提供）处理，再使用内置的 <code>onResError</code> 函数处理响应给客户端，最后抛出给 <code>app.onerror</code> 处理，应用通常可以在这里判断错误类型，根据情况将错误写入日志系统。</p>
<pre><code class="language-js"><span class="hljs-comment">// default</span>
app.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-comment">// ignore null and response error</span>
  <span class="hljs-keyword">if</span> (err == <span class="hljs-literal">null</span> || (err.status &amp;&amp; err.status &lt; <span class="hljs-number">500</span>)) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">if</span> (!util.isError(err)) err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'non-error thrown: '</span> + err)

  <span class="hljs-comment">// catch system error</span>
  <span class="hljs-keyword">let</span> msg = err.stack || err.toString()
  <span class="hljs-built_in">console</span>.error(msg.replace(<span class="hljs-regexp">/^/gm</span>, <span class="hljs-string">'  '</span>))
}
</code></pre>
<h4>app.toListener()</h4>
<p>返回 app request listener。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)
<span class="hljs-keyword">const</span> toa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'toa'</span>)

<span class="hljs-keyword">const</span> app = toa()
<span class="hljs-keyword">const</span> server = http.createServer(app.toListener())
server.listen(<span class="hljs-number">3000</span>)
</code></pre>
<p>等效于：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> toa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'toa'</span>)

<span class="hljs-keyword">const</span> app = toa()
app.listen(<span class="hljs-number">3000</span>)
</code></pre>
<h4>app.listen(port, [hostname], [backlog], [callback])</h4>
<h4>app.listen(path, [callback])</h4>
<h4>app.listen(handle, [callback])</h4>
<p>返回 <code>server</code>，用法与 <code>httpServer.listen</code> 一致。</p>
<pre><code class="language-js"><span class="hljs-comment">// 与 httpServer.listen 一致</span>
app.listen(<span class="hljs-number">3000</span>)
</code></pre>
<hr>
<h2 id="doc-context">Context</h2>
<p>Similar to <a href="https://github.com/koajs/koa/blob/master/docs/api/context.md">Koa’s Context</a></p>
<h3>Difference from Koa</h3>
<ul>
<li>remove <code>ctx.app</code></li>
<li>add <code>ctx.thunk</code> method, it is thunk function that bound a scope with <code>onerror</code>.</li>
<li>add <code>ctx.end</code> method, use to stopping request process and respond immediately.</li>
<li>add <code>ctx.after</code> method, use to add hooks that run after middlewares and before respond.</li>
<li>add <code>ctx.catchStream</code> method, used to catch stream’s error or clean stream when some error.</li>
<li>add <code>ctx.ended</code> property, indicates that the response ended.</li>
<li>add <code>ctx.finished</code> property, indicates that the response finished successfully.</li>
<li>add <code>ctx.closed</code> property, indicates that the response closed unexpectedly.</li>
<li>context is a <code>EventEmitter</code> instance</li>
</ul>
<p><code>Context</code> object encapsulates node’s <code>request</code> and <code>response</code> objects into a single object which provides many helpful methods for writing web applications and APIs. These operations are used so frequently in HTTP server development that they are added at this level instead of a higher level framework, which would force middleware to re-implement this common functionality.</p>
<p>A <code>Context</code> is created <em>per</em> request, and is referenced in middleware as the receiver, or the <code>this</code> identifier, as shown in the following snippet:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> app = Toa(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span> <span class="hljs-comment">// is the Context</span>
  <span class="hljs-keyword">this</span>.request <span class="hljs-comment">// is a toa Request</span>
  <span class="hljs-keyword">this</span>.response <span class="hljs-comment">// is a toa Response</span>
})

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span> <span class="hljs-comment">// is the Context</span>
  <span class="hljs-keyword">this</span>.request <span class="hljs-comment">// is a toa Request</span>
  <span class="hljs-keyword">this</span>.response <span class="hljs-comment">// is a toa Response</span>
})
</code></pre>
<p>Many of the context’s accessors and methods simply delegate to their <code>ctx.request</code> or <code>ctx.response</code> equivalents for convenience, and are otherwise identical. For example <code>ctx.type</code> and <code>ctx.length</code> delegate to the <code>response</code> object, and <code>ctx.path</code> and <code>ctx.method</code> delegate to the <code>request</code>.</p>
<h3>Events</h3>
<h4>‘close’</h4>
<p>Emitted after a HTTP request closed, indicates that the socket has been closed, and <code>context.closed</code> will be <code>true</code>.</p>
<h4>‘end’</h4>
<p>Emitted after respond() was called, indicates that body was sent. and <code>context.ended</code> will be <code>true</code></p>
<h4>‘finish’</h4>
<p>Emitted after a HTTP response finished. and <code>context.finished</code> will be <code>true</code>.</p>
<h4>‘error’</h4>
<p>A context always listen <code>'error'</code> event by <code>ctx.onerror</code>. <code>ctx.onerror</code> is a <strong>immutable</strong> error handle. So you can use <code>ctx.emit('error', error)</code> to deal with your exception or error.</p>
<h3>API</h3>
<p><code>Context</code> specific methods and accessors.</p>
<h4>ctx.thunk([thunkable])</h4>
<p>A thunk function that bound a scope.</p>
<ul>
<li><code>thunkable</code> thunkable value, see: <a href="https://github.com/thunks/thunks">https://github.com/thunks/thunks</a></li>
</ul>
<h4>ctx.end([message])</h4>
<p>Use to stopping request process and respond immediately. <strong>It should not run in <code>try catch</code> block, otherwise <code>onstop</code> will not be trigger</strong>.</p>
<ul>
<li><code>message</code> String, see: <a href="https://github.com/thunks/thunks">https://github.com/thunks/thunks</a></li>
</ul>
<h4>ctx.after(function () {})</h4>
<h4>ctx.after(function (callback) {})</h4>
<h4>ctx.after(function * () {})</h4>
<h4>ctx.after(async function () {})</h4>
<p>Add hooks dynamicly. Hooks will be executed in LIFO order after middlewares, but before <code>respond</code>.</p>
<h4>ctx.req</h4>
<p>Node’s <code>request</code> object.</p>
<h4>ctx.res</h4>
<p>Node’s <code>response</code> object.</p>
<p>Bypassing Toa’s response handling is <strong>not supported</strong>. Avoid using the following node properties:</p>
<ul>
<li><code>res.statusCode</code></li>
<li><code>res.writeHead()</code></li>
<li><code>res.write()</code></li>
<li><code>res.end()</code></li>
</ul>
<h4>ctx.request</h4>
<p>A Toa <code>Request</code> object.</p>
<h4>ctx.response</h4>
<p>A Toa <code>Response</code> object.</p>
<h4>ctx.state</h4>
<p>The recommended namespace for passing information through middleware and to your frontend views.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.state.user = <span class="hljs-keyword">yield</span> User.find(id)
</code></pre>
<h4>ctx.cookies.get(name, [options])</h4>
<p>Get cookie <code>name</code> with <code>options</code>:</p>
<ul>
<li><code>signed</code> the cookie requested should be signed</li>
</ul>
<p>Toa uses the <a href="https://github.com/jed/cookies">cookies</a> module where options are simply passed.</p>
<h4>ctx.cookies.set(name, value, [options])</h4>
<p>Set cookie <code>name</code> to <code>value</code> with <code>options</code>:</p>
<ul>
<li><code>signed</code> sign the cookie value</li>
<li><code>expires</code> a <code>Date</code> for cookie expiration</li>
<li><code>path</code> cookie path, <code>/'</code> by default</li>
<li><code>domain</code> cookie domain</li>
<li><code>secure</code> secure cookie</li>
<li><code>httpOnly</code> server-accessible cookie, <strong>true</strong> by default</li>
</ul>
<p>Toa uses the <a href="https://github.com/jed/cookies">cookies</a> module where options are simply passed.</p>
<h4>ctx.throw([msg], [status], [properties])</h4>
<p>Helper method to throw an error with a <code>.status</code> property defaulting to <code>500</code> that will allow Toa to respond appropriately. The following combinations are allowed:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.throw(<span class="hljs-number">403</span>)
<span class="hljs-keyword">this</span>.throw(<span class="hljs-string">'name required'</span>, <span class="hljs-number">400</span>)
<span class="hljs-keyword">this</span>.throw(<span class="hljs-number">400</span>, <span class="hljs-string">'name required'</span>)
<span class="hljs-keyword">this</span>.throw(<span class="hljs-string">'something exploded'</span>)
</code></pre>
<p>For example <code>this.throw('name required', 400)</code> is equivalent to:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'name required'</span>)
err.status = <span class="hljs-number">400</span>
<span class="hljs-keyword">throw</span> err
</code></pre>
<p>Note that these are user-level errors and are flagged with <code>err.expose</code> meaning the messages are appropriate for client responses, which is typically not the case for error messages since you do not want to leak failure details.</p>
<p>You may optionally pass a <code>properties</code> object which is merged into the error as-is, useful for decorating machine-friendly errors which are reported to the requester upstream.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.throw(<span class="hljs-number">401</span>, <span class="hljs-string">'access_denied'</span>, {<span class="hljs-attr">user</span>: user})
<span class="hljs-keyword">this</span>.throw(<span class="hljs-string">'access_denied'</span>, {<span class="hljs-attr">user</span>: user})
</code></pre>
<p>Toa uses <a href="https://github.com/jshttp/http-errors">http-errors</a> to create errors.</p>
<h4>ctx.createError([status], [msg], [properties])</h4>
<p>Similar to <code>ctx.throw</code>, create a error object, but don’t throw.</p>
<h4>ctx.assert(value, [status], [msg], [properties])</h4>
<p>Helper method to throw an error similar to <code>.throw()</code> when <code>!value</code>. Similar to node’s <a href="http://nodejs.org/api/assert.html">assert()</a> method.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.assert(<span class="hljs-keyword">this</span>.state.user, <span class="hljs-number">401</span>, <span class="hljs-string">'User not found. Please login!'</span>)
</code></pre>
<p>Toa uses <a href="https://github.com/jshttp/http-assert">http-assert</a> for assertions.</p>
<h4>ctx.respond</h4>
<p>To bypass Toa’s built-in response handling, you may explicitly set <code>this.respond = false</code>. Use this if you want to write to the raw <code>res</code> object instead of letting Toa handle the response for you.</p>
<p>Note that using this is <strong>not</strong> supported by Toa. This may break intended functionality of Toa middleware and Toa itself. Using this property is considered a hack and is only a convenience to those wishing to use traditional <code>fn(req, res)</code> functions and middleware within Toa.</p>
<h4>ctx.catchStream(stream)</h4>
<p>Catch a <code>stream</code>'s error, if ‘error’ event emit from the stream, the error will be throw to Thunk’s <code>onerror</code> and response it.</p>
<h3>Request aliases</h3>
<p>The following accessors and alias <a href="request.md">Request</a> equivalents:</p>
<ul>
<li><code>ctx.header</code></li>
<li><code>ctx.headers</code></li>
<li><code>ctx.method</code></li>
<li><code>ctx.method=</code></li>
<li><code>ctx.url</code></li>
<li><code>ctx.url=</code></li>
<li><code>ctx.origin</code></li>
<li><code>ctx.originalUrl</code></li>
<li><code>ctx.href</code></li>
<li><code>ctx.path</code></li>
<li><code>ctx.path=</code></li>
<li><code>ctx.query</code></li>
<li><code>ctx.query=</code></li>
<li><code>ctx.querystring</code></li>
<li><code>ctx.querystring=</code></li>
<li><code>ctx.host</code></li>
<li><code>ctx.hostname</code></li>
<li><code>ctx.fresh</code></li>
<li><code>ctx.stale</code></li>
<li><code>ctx.socket</code></li>
<li><code>ctx.protocol</code></li>
<li><code>ctx.secure</code></li>
<li><code>ctx.ip</code></li>
<li><code>ctx.ips</code></li>
<li><code>ctx.idempotent</code></li>
<li><code>ctx.subdomains</code></li>
<li><code>ctx.is()</code></li>
<li><code>ctx.accepts()</code></li>
<li><code>ctx.acceptsEncodings()</code></li>
<li><code>ctx.acceptsCharsets()</code></li>
<li><code>ctx.acceptsLanguages()</code></li>
<li><code>ctx.get()</code></li>
<li><code>ctx.search()</code></li>
</ul>
<h3>Response aliases</h3>
<p>The following accessors and alias <a href="response.md">Response</a> equivalents:</p>
<ul>
<li><code>ctx.body</code></li>
<li><code>ctx.body=</code></li>
<li><code>ctx.status</code></li>
<li><code>ctx.status=</code></li>
<li><code>ctx.message</code></li>
<li><code>ctx.message=</code></li>
<li><code>ctx.length=</code></li>
<li><code>ctx.length</code></li>
<li><code>ctx.type=</code></li>
<li><code>ctx.type</code></li>
<li><code>ctx.headerSent</code></li>
<li><code>ctx.redirect()</code></li>
<li><code>ctx.attachment()</code></li>
<li><code>ctx.set()</code></li>
<li><code>ctx.append()</code></li>
<li><code>ctx.remove()</code></li>
<li><code>ctx.vary()</code></li>
<li><code>ctx.lastModified=</code></li>
<li><code>ctx.etag=</code></li>
</ul>
<hr>
<h2 id="doc-request">Request</h2>
<p>The same as <a href="https://github.com/koajs/koa/blob/master/docs/api/request.md">Koa’s Request</a></p>
<p><code>Request</code> object is an abstraction on top of node’s vanilla request object, providing additional functionality that is useful for every day HTTP server development.</p>
<h3>API</h3>
<h4>request.header</h4>
<p>Request header object.</p>
<h4>request.headers</h4>
<p>Request header object. Alias as <code>request.header</code>.</p>
<h4>request.method</h4>
<p>Request method.</p>
<h4>request.method=</h4>
<p>Set request method, useful for implementing middleware such as <code>methodOverride()</code>.</p>
<h4>request.length</h4>
<p>Return request Content-Length as a number when present, or <code>undefined</code>.</p>
<h4>request.url</h4>
<p>Get request URL.</p>
<h4>request.url=</h4>
<p>Set request URL, useful for url rewrites.</p>
<h4>request.origin</h4>
<p>Get origin of URL.</p>
<h4>request.originalUrl</h4>
<p>Get request original URL.</p>
<h4>request.href</h4>
<p>Get full request URL, include <code>protocol</code>, <code>host</code> and <code>url</code>.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.request.href
<span class="hljs-comment">// =&gt; http://example.com/foo/bar?q=1</span>
</code></pre>
<h4>request.path</h4>
<p>Get request pathname.</p>
<h4>request.path=</h4>
<p>Set request pathname and retain query-string when present.</p>
<h4>request.querystring</h4>
<p>Get raw query string void of <code>?</code>.</p>
<h4>request.querystring=</h4>
<p>Set raw query string.</p>
<h4>request.search</h4>
<p>Get raw query string with the <code>?</code>.</p>
<h4>request.search=</h4>
<p>Set raw query string.</p>
<h4>request.host</h4>
<p>Get host (hostname:port) when present. Supports <code>X-Forwarded-Host</code> when <code>app.proxy</code> is <strong>true</strong>, otherwise <code>Host</code> is used.</p>
<h4>request.hostname</h4>
<p>Get hostname when present. Supports <code>X-Forwarded-Host</code> when <code>app.proxy</code> is <strong>true</strong>, otherwise <code>Host</code> is used.</p>
<h4>request.type</h4>
<p>Get request <code>Content-Type</code> void of parameters such as &quot;charset&quot;.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ct = <span class="hljs-keyword">this</span>.request.type
<span class="hljs-comment">// =&gt; "image/png"</span>
</code></pre>
<h4>request.charset</h4>
<p>Get request charset when present, or <code>undefined</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.request.charset
<span class="hljs-comment">// =&gt; "utf-8"</span>
</code></pre>
<h4>request.query</h4>
<p>Get parsed query-string, returning an empty object when no query-string is present. Note that this getter does <em>not</em> support nested parsing.</p>
<p>For example &quot;color=blue&amp;size=small&quot;:</p>
<pre><code class="language-js">{
  <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span>,
  <span class="hljs-attr">size</span>: <span class="hljs-string">'small'</span>
}
</code></pre>
<h4>request.query=</h4>
<p>Set query-string to the given object. Note that this setter does <em>not</em> support nested objects.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.query = {<span class="hljs-attr">next</span>: <span class="hljs-string">'/login'</span>}
</code></pre>
<h4>request.fresh</h4>
<p>Check if a request cache is &quot;fresh&quot;, aka the contents have not changed. This method is for cache negotiation between <code>If-None-Match</code> / <code>ETag</code>, and <code>If-Modified-Since</code> and <code>Last-Modified</code>. It should be referenced after setting one or more of these response headers.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.status = <span class="hljs-number">200</span>
<span class="hljs-keyword">this</span>.set(<span class="hljs-string">'ETag'</span>, <span class="hljs-string">'123'</span>)

<span class="hljs-comment">// cache is ok</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fresh) {
  <span class="hljs-keyword">this</span>.status = <span class="hljs-number">304</span>
  <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// cache is stale</span>
<span class="hljs-comment">// fetch new data</span>
<span class="hljs-keyword">this</span>.body = <span class="hljs-keyword">yield</span> db.find(<span class="hljs-string">'something'</span>)
</code></pre>
<h4>request.stale</h4>
<p>Inverse of <code>request.fresh</code>.</p>
<h4>request.protocol</h4>
<p>Return request protocol, “https” or &quot;http&quot;. Supports <code>X-Forwarded-Proto</code> when <code>app.proxy</code> is <strong>true</strong>.</p>
<h4>request.secure</h4>
<p>Shorthand for <code>this.protocol == &quot;https&quot;</code> to check if a request was issued via TLS.</p>
<h4>request.ip</h4>
<p>Request remote address. Supports <code>X-Forwarded-For</code> when <code>app.proxy</code> is <strong>true</strong>.</p>
<h4>request.ips</h4>
<p>When <code>X-Forwarded-For</code> is present and <code>app.proxy</code> is enabled an array of these ips is returned, ordered from upstream -&gt; downstream. When disabled an empty array is returned.</p>
<h4>request.subdomains</h4>
<p>Return subdomains as an array.</p>
<p>Subdomains are the dot-separated parts of the host before the main domain of the app. By default, the domain of the app is assumed to be the last two parts of the host. This can be changed by setting <code>app.subdomainOffset</code>.</p>
<p>For example, if the domain is &quot;tobi.ferrets.example.com&quot;:</p>
<p>If <code>app.subdomainOffset</code> is not set, this.subdomains is <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>.<br>
If <code>app.subdomainOffset</code> is 3, this.subdomains is <code>[&quot;tobi&quot;]</code>.</p>
<h4>request.is(types...)</h4>
<p>Check if the incoming request contains the “Content-Type” header field, and it contains any of the give mime <code>type</code>s. If there is no request body, <code>null</code> is returned. If there is no content type, or the match fails <code>false</code> is returned. Otherwise, it returns the matching content-type.</p>
<pre><code class="language-js"><span class="hljs-comment">// With Content-Type: text/html; charset=utf-8</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'html'</span>) <span class="hljs-comment">// =&gt; 'html'</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'text/html'</span>) <span class="hljs-comment">// =&gt; 'text/html'</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'text/*'</span>, <span class="hljs-string">'text/html'</span>) <span class="hljs-comment">// =&gt; 'text/html'</span>

<span class="hljs-comment">// When Content-Type is application/json</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'json'</span>, <span class="hljs-string">'urlencoded'</span>) <span class="hljs-comment">// =&gt; 'json'</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'application/json'</span>) <span class="hljs-comment">// =&gt; 'application/json'</span>
<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'html'</span>, <span class="hljs-string">'application/*'</span>) <span class="hljs-comment">// =&gt; 'application/json'</span>

<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'html'</span>) <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>For example if you want to ensure that only images are sent to a given route:</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.is(<span class="hljs-string">'image/*'</span>)) {
  <span class="hljs-comment">// process</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">this</span>.throw(<span class="hljs-number">415</span>, <span class="hljs-string">'images only!'</span>)
}
</code></pre>
<h4>Content Negotiation</h4>
<p><code>Request</code> object includes helpful content negotiation utilities powered by <a href="http://github.com/expressjs/accepts">accepts</a> and <a href="https://github.com/federomero/negotiator">negotiator</a>. These utilities are:</p>
<ul>
<li><code>request.accepts(types)</code></li>
<li><code>request.acceptsEncodings(types)</code></li>
<li><code>request.acceptsCharsets(charsets)</code></li>
<li><code>request.acceptsLanguages(langs)</code></li>
</ul>
<p>If no types are supplied, <strong>all</strong> acceptable types are returned.</p>
<p>If multiple types are supplied, the best match will be returned. If no matches are found, a <code>false</code> is returned, and you should send a <code>406 &quot;Not Acceptable&quot;</code> response to the client.</p>
<p>In the case of missing accept headers where any type is acceptable, the first type will be returned. Thus, the order of types you supply is important.</p>
<h4>request.accepts(types)</h4>
<p>Check if the given <code>type(s)</code> is acceptable, returning the best match when true, otherwise <code>false</code>. The <code>type</code> value may be one or more mime type string such as &quot;application/json&quot;, the extension name such as &quot;json&quot;, or an array <code>[&quot;json&quot;, &quot;html&quot;, &quot;text/plain&quot;]</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept: text/html</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'html'</span>)
<span class="hljs-comment">// =&gt; "html"</span>

<span class="hljs-comment">// Accept: text/*, application/json</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'html'</span>)
<span class="hljs-comment">// =&gt; "html"</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'text/html'</span>)
<span class="hljs-comment">// =&gt; "text/html"</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'text'</span>)
<span class="hljs-comment">// =&gt; "json"</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'application/json'</span>)
<span class="hljs-comment">// =&gt; "application/json"</span>

<span class="hljs-comment">// Accept: text/*, application/json</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'image/png'</span>)
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'png'</span>)
<span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// Accept: text/*;q=.5, application/json</span>
<span class="hljs-keyword">this</span>.accepts([<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>])
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>)
<span class="hljs-comment">// =&gt; "json"</span>

<span class="hljs-comment">// No Accept header</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'html'</span>, <span class="hljs-string">'json'</span>)
<span class="hljs-comment">// =&gt; "html"</span>
<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'html'</span>)
<span class="hljs-comment">// =&gt; "json"</span>
</code></pre>
<p>You may call <code>this.accepts()</code> as many times as you like, or use a switch:</p>
<pre><code class="language-js"><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.accepts(<span class="hljs-string">'json'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'text'</span>)) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'json'</span>: <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">'html'</span>: <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>: <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">default</span>: <span class="hljs-keyword">this</span>.throw(<span class="hljs-number">406</span>, <span class="hljs-string">'json, html, or text only'</span>)
}
</code></pre>
<h4>request.acceptsEncodings(encodings)</h4>
<p>Check if <code>encodings</code> are acceptable, returning the best match when true, otherwise <code>false</code>. Note that you should include <code>identity</code> as one of the encodings!</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Encoding: gzip</span>
<span class="hljs-keyword">this</span>.acceptsEncodings(<span class="hljs-string">'gzip'</span>, <span class="hljs-string">'deflate'</span>, <span class="hljs-string">'identity'</span>)
<span class="hljs-comment">// =&gt; "gzip"</span>

<span class="hljs-keyword">this</span>.acceptsEncodings([<span class="hljs-string">'gzip'</span>, <span class="hljs-string">'deflate'</span>, <span class="hljs-string">'identity'</span>])
<span class="hljs-comment">// =&gt; "gzip"</span>
</code></pre>
<p>When no arguments are given all accepted encodings are returned as an array:</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Encoding: gzip, deflate</span>
<span class="hljs-keyword">this</span>.acceptsEncodings()
<span class="hljs-comment">// =&gt; ["gzip", "deflate", "identity"]</span>
</code></pre>
<p>Note that the <code>identity</code> encoding (which means no encoding) could be unacceptable if the client explicitly sends <code>identity;q=0</code>. Although this is an edge case, you should still handle the case where this method returns <code>false</code>.</p>
<h4>request.acceptsCharsets(charsets)</h4>
<p>Check if <code>charsets</code> are acceptable, returning the best match when true, otherwise <code>false</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5</span>
<span class="hljs-keyword">this</span>.acceptsCharsets(<span class="hljs-string">'utf-8'</span>, <span class="hljs-string">'utf-7'</span>)
<span class="hljs-comment">// =&gt; "utf-8"</span>

<span class="hljs-keyword">this</span>.acceptsCharsets([<span class="hljs-string">'utf-7'</span>, <span class="hljs-string">'utf-8'</span>])
<span class="hljs-comment">// =&gt; "utf-8"</span>
</code></pre>
<p>When no arguments are given all accepted charsets are returned as an array:</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5</span>
<span class="hljs-keyword">this</span>.acceptsCharsets()
<span class="hljs-comment">// =&gt; ["utf-8", "utf-7", "iso-8859-1"]</span>
</code></pre>
<h4>request.acceptsLanguages(langs)</h4>
<p>Check if <code>langs</code> are acceptable, returning the best match when true, otherwise <code>false</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Language: en;q=0.8, es, pt</span>
<span class="hljs-keyword">this</span>.acceptsLanguages(<span class="hljs-string">'es'</span>, <span class="hljs-string">'en'</span>)
<span class="hljs-comment">// =&gt; "es"</span>

<span class="hljs-keyword">this</span>.acceptsLanguages([<span class="hljs-string">'en'</span>, <span class="hljs-string">'es'</span>])
<span class="hljs-comment">// =&gt; "es"</span>
</code></pre>
<p>When no arguments are given all accepted languages are returned as an array:</p>
<pre><code class="language-js"><span class="hljs-comment">// Accept-Language: en;q=0.8, es, pt</span>
<span class="hljs-keyword">this</span>.acceptsLanguages()
<span class="hljs-comment">// =&gt; ["es", "pt", "en"]</span>
</code></pre>
<h4>request.idempotent</h4>
<p>Check if the request is idempotent.</p>
<h4>request.socket</h4>
<p>Return the request socket.</p>
<h4>request.get(field)</h4>
<p>Return request header.</p>
<hr>
<h2 id="doc-response">Response</h2>
<p>The same as <a href="https://github.com/koajs/koa/blob/master/docs/api/response.md">Koa’s Response</a></p>
<p><code>Response</code> object is an abstraction on top of node’s vanilla response object, providing additional functionality that is useful for every day HTTP server development.</p>
<h3>API</h3>
<h4>response.header</h4>
<p>Response header object.</p>
<h4>response.headers</h4>
<p>Response header object. Alias as <code>response.header</code>.</p>
<h4>response.socket</h4>
<p>Request socket.</p>
<h4>response.status</h4>
<p>Get response status. By default, <code>response.status</code> is not set unlike node’s <code>res.statusCode</code> which defaults to <code>200</code>.</p>
<h4>response.status=</h4>
<p>Set response status via numeric code:</p>
<ul>
<li>100 “continue”</li>
<li>101 “switching protocols”</li>
<li>102 “processing”</li>
<li>200 “ok”</li>
<li>201 “created”</li>
<li>202 “accepted”</li>
<li>203 “non-authoritative information”</li>
<li>204 “no content”</li>
<li>205 “reset content”</li>
<li>206 “partial content”</li>
<li>207 “multi-status”</li>
<li>300 “multiple choices”</li>
<li>301 “moved permanently”</li>
<li>302 “moved temporarily”</li>
<li>303 “see other”</li>
<li>304 “not modified”</li>
<li>305 “use proxy”</li>
<li>307 “temporary redirect”</li>
<li>400 “bad request”</li>
<li>401 “unauthorized”</li>
<li>402 “payment required”</li>
<li>403 “forbidden”</li>
<li>404 “not found”</li>
<li>405 “method not allowed”</li>
<li>406 “not acceptable”</li>
<li>407 “proxy authentication required”</li>
<li>408 “request time-out”</li>
<li>409 “conflict”</li>
<li>410 “gone”</li>
<li>411 “length required”</li>
<li>412 “precondition failed”</li>
<li>413 “request entity too large”</li>
<li>414 “request-uri too large”</li>
<li>415 “unsupported media type”</li>
<li>416 “requested range not satisfiable”</li>
<li>417 “expectation failed”</li>
<li>418 “i’m a teapot”</li>
<li>422 “unprocessable entity”</li>
<li>423 “locked”</li>
<li>424 “failed dependency”</li>
<li>425 “unordered collection”</li>
<li>426 “upgrade required”</li>
<li>428 “precondition required”</li>
<li>429 “too many requests”</li>
<li>431 “request header fields too large”</li>
<li>500 “internal server error”</li>
<li>501 “not implemented”</li>
<li>502 “bad gateway”</li>
<li>503 “service unavailable”</li>
<li>504 “gateway time-out”</li>
<li>505 “http version not supported”</li>
<li>506 “variant also negotiates”</li>
<li>507 “insufficient storage”</li>
<li>509 “bandwidth limit exceeded”</li>
<li>510 “not extended”</li>
<li>511 “network authentication required”</li>
</ul>
<p><strong>NOTE</strong>: don’t worry too much about memorizing these strings,<br>
if you have a typo an error will be thrown, displaying this list<br>
so you can make a correction.</p>
<h4>response.message</h4>
<p>Get response status message. By default, <code>response.message</code> is associated with <code>response.status</code>.</p>
<h4>response.message=</h4>
<p>Set response status message to the given value.</p>
<h4>response.length=</h4>
<p>Set response Content-Length to the given value.</p>
<h4>response.length</h4>
<p>Return response Content-Length as a number when present, or deduce from <code>this.body</code> when possible, or <code>undefined</code>.</p>
<h4>response.body</h4>
<p>Get response body.</p>
<h4>response.body=</h4>
<p>Set response body to one of the following:</p>
<ul>
<li><code>string</code> written</li>
<li><code>Buffer</code> written</li>
<li><code>Stream</code> piped</li>
<li><code>Object</code> json-stringified</li>
<li><code>null</code> no content response</li>
</ul>
<p>If <code>response.status</code> has not been set, Toa will automatically set the status to <code>200</code> or <code>204</code>.</p>
<h5>String</h5>
<p>The Content-Type is defaulted to text/html or text/plain, both with a default charset of utf-8. The Content-Length field is also set.</p>
<h5>Buffer</h5>
<p>The Content-Type is defaulted to application/octet-stream, and Content-Length is also set.</p>
<h5>Stream</h5>
<p>The Content-Type is defaulted to application/octet-stream.</p>
<h5>Object</h5>
<p>The Content-Type is defaulted to application/json.</p>
<h4>response.get(field)</h4>
<p>Get a response header field value with case-insensitive <code>field</code>.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> etag = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'etag'</span>)
</code></pre>
<h4>response.set(field, value)</h4>
<p>Set response header <code>field</code> to <code>value</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.set(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'no-cache'</span>)
</code></pre>
<h4>response.append(field, value)</h4>
<p>Append additional header <code>field</code> with value <code>val</code>.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.append(<span class="hljs-string">'Link'</span>, <span class="hljs-string">'&lt;http://127.0.0.1/&gt;'</span>)
</code></pre>
<h4>response.set(fields)</h4>
<p>Set several response header <code>fields</code> with an object:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.set({
  <span class="hljs-string">'ETag'</span>: <span class="hljs-string">'1234'</span>,
  <span class="hljs-string">'Last-Modified'</span>: date
})
</code></pre>
<h4>response.remove(field)</h4>
<p>Remove header <code>field</code>.</p>
<h4>response.type</h4>
<p>Get response <code>Content-Type</code> void of parameters such as &quot;charset&quot;.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ct = <span class="hljs-keyword">this</span>.type
<span class="hljs-comment">// =&gt; "image/png"</span>
</code></pre>
<h4>response.type=</h4>
<p>Set response <code>Content-Type</code> via mime string or file extension.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.type = <span class="hljs-string">'text/plain; charset=utf-8'</span>
<span class="hljs-keyword">this</span>.type = <span class="hljs-string">'image/png'</span>
<span class="hljs-keyword">this</span>.type = <span class="hljs-string">'.png'</span>
<span class="hljs-keyword">this</span>.type = <span class="hljs-string">'png'</span>
</code></pre>
<p>Note: when appropriate a <code>charset</code> is selected for you, for example <code>response.type = 'html'</code> will default to &quot;utf-8&quot;, however when explicitly defined in full as <code>response.type = 'text/html'</code> no charset is assigned.</p>
<h4>response.is(types...)</h4>
<p>Very similar to <code>this.request.is()</code>. Check whether the response type is one of the supplied types. This is particularly useful for creating middleware that manipulate responses.</p>
<h4>response.redirect(url, [alt])</h4>
<p>Perform a [302] redirect to <code>url</code>.</p>
<p>The string “back” is special-cased to provide Referrer support, when Referrer is not present <code>alt</code> or “/” is used.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'back'</span>)
<span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'back'</span>, <span class="hljs-string">'/index.html'</span>)
<span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'/login'</span>)
<span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'http://google.com'</span>)
</code></pre>
<p>To alter the default status of <code>302</code>, simply assign the status before or after this call. To alter the body, assign it after this call:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.status = <span class="hljs-number">301</span>
<span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'/cart'</span>)
<span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Redirecting to shopping cart'</span>
</code></pre>
<h4>response.attachment([filename])</h4>
<p>Set <code>Content-Disposition</code> to “attachment” to signal the client to prompt for download. Optionally specify the <code>filename</code> of the download.</p>
<h4>response.headerSent</h4>
<p>Check if a response header has already been sent. Useful for seeing if the client may be notified on error.</p>
<h4>response.lastModified</h4>
<p>Return the <code>Last-Modified</code> header as a <code>Date</code>, if it exists.</p>
<h4>response.lastModified=</h4>
<p>Set the <code>Last-Modified</code> header as an appropriate UTC string. You can either set it as a <code>Date</code> or date string.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.response.lastModified = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre>
<h4>response.etag=</h4>
<p>Set the ETag of a response including the wrapped <code>&quot;</code>s. Note that there is no corresponding <code>response.etag</code> getter.</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.response.etag = crypto.createHash(<span class="hljs-string">'md5'</span>).update(<span class="hljs-keyword">this</span>.body).digest(<span class="hljs-string">'hex'</span>)
</code></pre>
<h4>response.vary(field)</h4>
<p>Vary on <code>field</code>.</p>
<hr>

      </div>
    </div>
  </div>
</section>

  <section class="resources" id="resources">
  <div class="container">
    <div class="card">
      <div class="card-header with-border">
        <h2>Resources</h2>
      </div>
      <div class="card-main">
        <p class="module-desc">与 Koa 一样， Toa 也没有绑定过多的功能，而仅仅提供了一个轻量优雅的函数库，和强大的扩展能力。<br>
        使用者可以根据自己的需求选择独立的功能模块或中间件，或自己实现相关功能模块。<br>
        以下是 <strong>Toajs</strong> 提供的基础性的功能模块。它们已能满足大多数的应用需求。</p>
        <div class="row modules-list">
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-ejs" target="_blank" class="module">
              <div class="module-icon icon-ejs">Ejs</div>
              Ejs render module for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-mejs" target="_blank" class="module">
              <div class="module-icon icon-mejs">Mejs</div>
              Mejs render module for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-i18n" target="_blank" class="module">
              <div class="module-icon icon-i18n">I18n</div>
              I18n middleware for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-body" target="_blank" class="module">
              <div class="module-icon icon-body">Body</div>
              Request body parser for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-token" target="_blank" class="module">
              <div class="module-icon icon-token">Token</div>
              Token based authentication for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-router" target="_blank" class="module">
              <div class="module-icon icon-router">Router</div>
              A router for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-static" target="_blank" class="module">
              <div class="module-icon icon-static">Static</div>
              A static server module for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-favicon" target="_blank" class="module">
              <div class="module-icon icon-favicon">Favi..</div>
              Favicon middleware for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-session" target="_blank" class="module">
              <div class="module-icon icon-session">Sess..</div>
              Session middleware for toa.
            </a>
          </div>
          <div class="col-xs-6">
            <a href="https://github.com/toajs/toa-compress" target="_blank" class="module">
              <div class="module-icon icon-compress">Comp..</div>
              Compress responses middleware for toa.
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

  <svg id="thanks-gap" xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100" viewBox="0 0 100 100" preserveAspectRatio="none">
  <path d="M-5 100 Q 0 20 5 100 Z
    M0 100 Q 5 0 10 100
    M5 100 Q 10 30 15 100
    M10 100 Q 15 10 20 100
    M15 100 Q 20 30 25 100
    M20 100 Q 25 -10 30 100
    M25 100 Q 30 10 35 100
    M30 100 Q 35 30 40 100
    M35 100 Q 40 10 45 100
    M40 100 Q 45 50 50 100
    M45 100 Q 50 20 55 100
    M50 100 Q 55 40 60 100
    M55 100 Q 60 60 65 100
    M60 100 Q 65 50 70 100
    M65 100 Q 70 20 75 100
    M70 100 Q 75 45 80 100
    M75 100 Q 80 30 85 100
    M80 100 Q 85 20 90 100
    M85 100 Q 90 50 95 100
    M90 100 Q 95 25 100 100
    M95 100 Q 100 15 105 100 Z">
  </path>
</svg>

<section class="thanks" id="thanks">
  <div class="container">
    <h2 class="title">Thanks to Koa and it’s authors</h2>
    <div class="row">
      <div class="koa-wrap col-sm-3">
        <a href="http://koajs.com" target="_blank">
          <span class="koa-logo">
            koa
          </span>
        </a>
        <hr>
      </div>
      <div class="col-sm-9">
        <ul class="row authors-list">
          <li class="col-sm-3">
            <a href="https://github.com/tj" target="_blank">
              <img src="/static/images/thanks/author-tj.1398cf7c.jpg">
              <br>
              TJ Holowaychuk
            </a>
          </li>
          <li class="col-sm-3">
            <a href="https://github.com/jonathanong" target="_blank">
              <img src="/static/images/thanks/author-jo.b502dfe8.jpg">
              <br>
              Jonathan Ong
            </a>
          <li class="col-sm-3">
            <a href="https://github.com/juliangruber" target="_blank">
              <img src="/static/images/thanks/author-jg.fce36d7f.jpg">
              <br>
              Julian Gruber
            </a>
          </li>
          <li class="col-sm-3">
            <a href="https://github.com/dead-horse" target="_blank">
              <img src="/static/images/thanks/author-yyh.c0ef5e8a.jpg">
              <br>
              Yiyu He
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</section>

  <section class="copyright">
  <div class="container">
    <p>Copyright © 2015-2017 Toajs Released under the MIT license.</p>
  </div>
</section>

</div>

    
    <script src="static/js/lib.20bffa5c.js"></script>
    <script src="static/js/app.456c01e8.js"></script>
    
  </body>
</html>
